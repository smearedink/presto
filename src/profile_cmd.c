/*****
  command line parser -- generated by clig
  (http://wsd.iitb.fhg.de/~kir/clighome/)

  The Command line parser `clig':
  (C) 1995---2001 Harald Kirsch (kirschh@lionbioscience.com)
*****/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <float.h>
#include <math.h>

#include "profile_cmd.h"

char *Program;

/*@-null*/

static Cmdline cmd = {
  /***** -phs: Offset phase for the profile */
    /* phsP = */ 1,
    /* phs = */ 0,
    /* phsC = */ 1,
  /***** -p: The folding period (s) */
    /* pP = */ 0,
    /* p = */ (double) 0,
    /* pC = */ 0,
  /***** -pd: The folding period derivative (s/s) */
    /* pdP = */ 1,
    /* pd = */ 0,
    /* pdC = */ 1,
  /***** -pdd: The folding period 2nd derivative (s/s^2) */
    /* pddP = */ 1,
    /* pdd = */ 0,
    /* pddC = */ 1,
  /***** -f: The folding frequency (hz) */
    /* fP = */ 0,
    /* f = */ (double) 0,
    /* fC = */ 0,
  /***** -fd: The folding frequency derivative (hz/s) */
    /* fdP = */ 1,
    /* fd = */ 0,
    /* fdC = */ 1,
  /***** -fdd: The folding frequency 2nd derivative (hz/s^2) */
    /* fddP = */ 1,
    /* fdd = */ 0,
    /* fddC = */ 1,
  /***** -n: The number of bins in the profile.  Defaults to the number of sampling bins which correspond to one folded period */
    /* proflenP = */ 0,
    /* proflen = */ (int) 0,
    /* proflenC = */ 0,
  /***** -psr: Name of pulsar to fold (do not include J or B) */
    /* psrnameP = */ 0,
    /* psrname = */ (char *) 0,
    /* psrnameC = */ 0,
  /***** -rzwcand: The candidate number to fold from 'infile'_rzw.cand */
    /* rzwcandP = */ 0,
    /* rzwcand = */ (int) 0,
    /* rzwcandC = */ 0,
  /***** -rzwfile: Name of the rzw search file to use (include the full name of the file) */
    /* rzwfileP = */ 0,
    /* rzwfile = */ (char *) 0,
    /* rzwfileC = */ 0,
  /***** -bincand: Fold a binary pulsar but take the input data from this candidate number in 'infile'_bin.cand */
    /* bincandP = */ 0,
    /* bincand = */ (int) 0,
    /* bincandC = */ 0,
  /***** -onoff: A list of white-space separated pairs of numbers from 0.0 to 1.0 that designate barycentric times in our data set when we will actually keep the data. (i.e. '-onoff 0.1 0.4 0.7 0.9' means that we will fold the data set during the barycentric times 0.1-0.4 and 0.7-0.9 of the total time length of the data set) */
    /* onoffP = */ 0,
    /* onoff = */ (char *) 0,
    /* onoffC = */ 0,
  /***** -bin: Fold a binary pulsar.  Must include all of the following parameters */
    /* binaryP = */ 0,
  /***** -pb: The orbital period (s) */
    /* pbP = */ 0,
    /* pb = */ (double) 0,
    /* pbC = */ 0,
  /***** -x: The projected orbital semi-major axis (lt-sec) */
    /* asinicP = */ 0,
    /* asinic = */ (double) 0,
    /* asinicC = */ 0,
  /***** -e: The orbital eccentricity */
    /* eP = */ 1,
    /* e = */ 0,
    /* eC = */ 1,
  /***** -To: The time of periastron passage (MJD) */
    /* ToP = */ 0,
    /* To = */ (double) 0,
    /* ToC = */ 0,
  /***** -w: Longitude of periastron (deg) */
    /* wP = */ 0,
    /* w = */ (double) 0,
    /* wC = */ 0,
  /***** -wdot: Rate of advance of periastron (deg/yr) */
    /* wdotP = */ 1,
    /* wdot = */ 0,
    /* wdotC = */ 1,
  /***** -xwin: Send graphics output to the screen */
    /* xwinP = */ 0,
  /***** -ps: Send graphics output to a Postscript file */
    /* psP = */ 0,
  /***** -both: Send graphics output both the screen and a Postscript file */
    /* bothP = */ 0,
  /***** -disp: Don't calculate a new profile.  Just display a previously calculated profile in 'infile'.prof.  Must be called with either -ps or -xwin */
    /* dispP = */ 0,
  /***** -mak: Determine folding parameters from 'infile.mak' */
    /* makefileP = */ 0,
  /***** -noerr: Do not plot error bars */
    /* noerrP = */ 0,
  /***** uninterpreted rest of command line */
    /* argc = */ 0,
    /* argv = */ (char **) 0,
  /***** the original command line concatenated */
    /* full_cmd_line = */ NULL
};

/*@=null*/

/***** let LCLint run more smoothly */
/*@-predboolothers*/
/*@-boolops*/


/******************************************************************/
/*****
 This is a bit tricky. We want to make a difference between overflow
 and underflow and we want to allow v==Inf or v==-Inf but not
 v>FLT_MAX. 

 We don't use fabs to avoid linkage with -lm.
*****/
static void checkFloatConversion(double v, char *option, char *arg)
{
    char *err = NULL;

    if ((errno == ERANGE && v != 0.0)   /* even double overflowed */
        ||(v < HUGE_VAL && v > -HUGE_VAL && (v < 0.0 ? -v : v) > (double) FLT_MAX)) {
        err = "large";
    } else if ((errno == ERANGE && v == 0.0)
               || (v != 0.0 && (v < 0.0 ? -v : v) < (double) FLT_MIN)) {
        err = "small";
    }
    if (err) {
        fprintf(stderr,
                "%s: parameter `%s' of option `%s' to %s to represent\n",
                Program, arg, option, err);
        exit(EXIT_FAILURE);
    }
}

int getIntOpt(int argc, char **argv, int i, int *value, int force)
{
    char *end;
    long v;

    if (++i >= argc)
        goto nothingFound;

    errno = 0;
    v = strtol(argv[i], &end, 0);

  /***** check for conversion error */
    if (end == argv[i])
        goto nothingFound;

  /***** check for surplus non-whitespace */
    while (isspace((int) *end))
        end += 1;
    if (*end)
        goto nothingFound;

  /***** check if it fits into an int */
    if (errno == ERANGE || v > (long) INT_MAX || v < (long) INT_MIN) {
        fprintf(stderr,
                "%s: parameter `%s' of option `%s' to large to represent\n",
                Program, argv[i], argv[i - 1]);
        exit(EXIT_FAILURE);
    }
    *value = (int) v;

    return i;

  nothingFound:
    if (!force)
        return i - 1;

    fprintf(stderr,
            "%s: missing or malformed integer value after option `%s'\n",
            Program, argv[i - 1]);
    exit(EXIT_FAILURE);
}

/**********************************************************************/

int getIntOpts(int argc, char **argv, int i, int **values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
    int alloced, used;
    char *end;
    long v;
    if (i + cmin >= argc) {
        fprintf(stderr,
                "%s: option `%s' wants at least %d parameters\n",
                Program, argv[i], cmin);
        exit(EXIT_FAILURE);
    }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
    alloced = cmin + 4;
    *values = (int *) calloc((size_t) alloced, sizeof(int));
    if (!*values) {
      outMem:
        fprintf(stderr,
                "%s: out of memory while parsing option `%s'\n", Program, argv[i]);
        exit(EXIT_FAILURE);
    }

    for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++) {
        if (used == alloced) {
            alloced += 8;
            *values = (int *) realloc(*values, alloced * sizeof(int));
            if (!*values)
                goto outMem;
        }

        errno = 0;
        v = strtol(argv[used + i + 1], &end, 0);

    /***** check for conversion error */
        if (end == argv[used + i + 1])
            break;

    /***** check for surplus non-whitespace */
        while (isspace((int) *end))
            end += 1;
        if (*end)
            break;

    /***** check for overflow */
        if (errno == ERANGE || v > (long) INT_MAX || v < (long) INT_MIN) {
            fprintf(stderr,
                    "%s: parameter `%s' of option `%s' to large to represent\n",
                    Program, argv[i + used + 1], argv[i]);
            exit(EXIT_FAILURE);
        }

        (*values)[used] = (int) v;

    }

    if (used < cmin) {
        fprintf(stderr,
                "%s: parameter `%s' of `%s' should be an "
                "integer value\n", Program, argv[i + used + 1], argv[i]);
        exit(EXIT_FAILURE);
    }

    return i + used;
}

/**********************************************************************/

int getLongOpt(int argc, char **argv, int i, long *value, int force)
{
    char *end;

    if (++i >= argc)
        goto nothingFound;

    errno = 0;
    *value = strtol(argv[i], &end, 0);

  /***** check for conversion error */
    if (end == argv[i])
        goto nothingFound;

  /***** check for surplus non-whitespace */
    while (isspace((int) *end))
        end += 1;
    if (*end)
        goto nothingFound;

  /***** check for overflow */
    if (errno == ERANGE) {
        fprintf(stderr,
                "%s: parameter `%s' of option `%s' to large to represent\n",
                Program, argv[i], argv[i - 1]);
        exit(EXIT_FAILURE);
    }
    return i;

  nothingFound:
  /***** !force means: this parameter may be missing.*/
    if (!force)
        return i - 1;

    fprintf(stderr,
            "%s: missing or malformed value after option `%s'\n",
            Program, argv[i - 1]);
    exit(EXIT_FAILURE);
}

/**********************************************************************/

int getLongOpts(int argc, char **argv, int i, long **values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
    int alloced, used;
    char *end;

    if (i + cmin >= argc) {
        fprintf(stderr,
                "%s: option `%s' wants at least %d parameters\n",
                Program, argv[i], cmin);
        exit(EXIT_FAILURE);
    }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
    alloced = cmin + 4;
    *values = calloc((size_t) alloced, sizeof(long));
    if (!*values) {
      outMem:
        fprintf(stderr,
                "%s: out of memory while parsing option `%s'\n", Program, argv[i]);
        exit(EXIT_FAILURE);
    }

    for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++) {
        if (used == alloced) {
            alloced += 8;
            *values = realloc(*values, alloced * sizeof(long));
            if (!*values)
                goto outMem;
        }

        errno = 0;
        (*values)[used] = strtol(argv[used + i + 1], &end, 0);

    /***** check for conversion error */
        if (end == argv[used + i + 1])
            break;

    /***** check for surplus non-whitespace */
        while (isspace((int) *end))
            end += 1;
        if (*end)
            break;

    /***** check for overflow */
        if (errno == ERANGE) {
            fprintf(stderr,
                    "%s: parameter `%s' of option `%s' to large to represent\n",
                    Program, argv[i + used + 1], argv[i]);
            exit(EXIT_FAILURE);
        }

    }

    if (used < cmin) {
        fprintf(stderr,
                "%s: parameter `%s' of `%s' should be an "
                "integer value\n", Program, argv[i + used + 1], argv[i]);
        exit(EXIT_FAILURE);
    }

    return i + used;
}

/**********************************************************************/

int getFloatOpt(int argc, char **argv, int i, float *value, int force)
{
    char *end;
    double v;

    if (++i >= argc)
        goto nothingFound;

    errno = 0;
    v = strtod(argv[i], &end);

  /***** check for conversion error */
    if (end == argv[i])
        goto nothingFound;

  /***** check for surplus non-whitespace */
    while (isspace((int) *end))
        end += 1;
    if (*end)
        goto nothingFound;

  /***** check for overflow */
    checkFloatConversion(v, argv[i - 1], argv[i]);

    *value = (float) v;

    return i;

  nothingFound:
    if (!force)
        return i - 1;

    fprintf(stderr,
            "%s: missing or malformed float value after option `%s'\n",
            Program, argv[i - 1]);
    exit(EXIT_FAILURE);

}

/**********************************************************************/

int getFloatOpts(int argc, char **argv, int i, float **values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
    int alloced, used;
    char *end;
    double v;

    if (i + cmin >= argc) {
        fprintf(stderr,
                "%s: option `%s' wants at least %d parameters\n",
                Program, argv[i], cmin);
        exit(EXIT_FAILURE);
    }

  /***** 
    alloc a bit more than cmin values.
  *****/
    alloced = cmin + 4;
    *values = (float *) calloc((size_t) alloced, sizeof(float));
    if (!*values) {
      outMem:
        fprintf(stderr,
                "%s: out of memory while parsing option `%s'\n", Program, argv[i]);
        exit(EXIT_FAILURE);
    }

    for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++) {
        if (used == alloced) {
            alloced += 8;
            *values = (float *) realloc(*values, alloced * sizeof(float));
            if (!*values)
                goto outMem;
        }

        errno = 0;
        v = strtod(argv[used + i + 1], &end);

    /***** check for conversion error */
        if (end == argv[used + i + 1])
            break;

    /***** check for surplus non-whitespace */
        while (isspace((int) *end))
            end += 1;
        if (*end)
            break;

    /***** check for overflow */
        checkFloatConversion(v, argv[i], argv[i + used + 1]);

        (*values)[used] = (float) v;
    }

    if (used < cmin) {
        fprintf(stderr,
                "%s: parameter `%s' of `%s' should be a "
                "floating-point value\n", Program, argv[i + used + 1], argv[i]);
        exit(EXIT_FAILURE);
    }

    return i + used;
}

/**********************************************************************/

int getDoubleOpt(int argc, char **argv, int i, double *value, int force)
{
    char *end;

    if (++i >= argc)
        goto nothingFound;

    errno = 0;
    *value = strtod(argv[i], &end);

  /***** check for conversion error */
    if (end == argv[i])
        goto nothingFound;

  /***** check for surplus non-whitespace */
    while (isspace((int) *end))
        end += 1;
    if (*end)
        goto nothingFound;

  /***** check for overflow */
    if (errno == ERANGE) {
        fprintf(stderr,
                "%s: parameter `%s' of option `%s' to %s to represent\n",
                Program, argv[i], argv[i - 1], (*value == 0.0 ? "small" : "large"));
        exit(EXIT_FAILURE);
    }

    return i;

  nothingFound:
    if (!force)
        return i - 1;

    fprintf(stderr,
            "%s: missing or malformed value after option `%s'\n",
            Program, argv[i - 1]);
    exit(EXIT_FAILURE);

}

/**********************************************************************/

int getDoubleOpts(int argc, char **argv, int i, double **values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
    int alloced, used;
    char *end;

    if (i + cmin >= argc) {
        fprintf(stderr,
                "%s: option `%s' wants at least %d parameters\n",
                Program, argv[i], cmin);
        exit(EXIT_FAILURE);
    }

  /***** 
    alloc a bit more than cmin values.
  *****/
    alloced = cmin + 4;
    *values = (double *) calloc((size_t) alloced, sizeof(double));
    if (!*values) {
      outMem:
        fprintf(stderr,
                "%s: out of memory while parsing option `%s'\n", Program, argv[i]);
        exit(EXIT_FAILURE);
    }

    for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++) {
        if (used == alloced) {
            alloced += 8;
            *values = (double *) realloc(*values, alloced * sizeof(double));
            if (!*values)
                goto outMem;
        }

        errno = 0;
        (*values)[used] = strtod(argv[used + i + 1], &end);

    /***** check for conversion error */
        if (end == argv[used + i + 1])
            break;

    /***** check for surplus non-whitespace */
        while (isspace((int) *end))
            end += 1;
        if (*end)
            break;

    /***** check for overflow */
        if (errno == ERANGE) {
            fprintf(stderr,
                    "%s: parameter `%s' of option `%s' to %s to represent\n",
                    Program, argv[i + used + 1], argv[i],
                    ((*values)[used] == 0.0 ? "small" : "large"));
            exit(EXIT_FAILURE);
        }

    }

    if (used < cmin) {
        fprintf(stderr,
                "%s: parameter `%s' of `%s' should be a "
                "double value\n", Program, argv[i + used + 1], argv[i]);
        exit(EXIT_FAILURE);
    }

    return i + used;
}

/**********************************************************************/

/**
  force will be set if we need at least one argument for the option.
*****/
int getStringOpt(int argc, char **argv, int i, char **value, int force)
{
    i += 1;
    if (i >= argc) {
        if (force) {
            fprintf(stderr, "%s: missing string after option `%s'\n",
                    Program, argv[i - 1]);
            exit(EXIT_FAILURE);
        }
        return i - 1;
    }

    if (!force && argv[i][0] == '-')
        return i - 1;
    *value = argv[i];
    return i;
}

/**********************************************************************/

int getStringOpts(int argc, char **argv, int i, char ***values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
    int alloced, used;

    if (i + cmin >= argc) {
        fprintf(stderr,
                "%s: option `%s' wants at least %d parameters\n",
                Program, argv[i], cmin);
        exit(EXIT_FAILURE);
    }

    alloced = cmin + 4;

    *values = (char **) calloc((size_t) alloced, sizeof(char *));
    if (!*values) {
      outMem:
        fprintf(stderr,
                "%s: out of memory during parsing of option `%s'\n", Program,
                argv[i]);
        exit(EXIT_FAILURE);
    }

    for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++) {
        if (used == alloced) {
            alloced += 8;
            *values = (char **) realloc(*values, alloced * sizeof(char *));
            if (!*values)
                goto outMem;
        }

        if (used >= cmin && argv[used + i + 1][0] == '-')
            break;
        (*values)[used] = argv[used + i + 1];
    }

    if (used < cmin) {
        fprintf(stderr,
                "%s: less than %d parameters for option `%s', only %d found\n",
                Program, cmin, argv[i], used);
        exit(EXIT_FAILURE);
    }

    return i + used;
}

/**********************************************************************/

void checkIntLower(char *opt, int *values, int count, int max)
{
    int i;

    for (i = 0; i < count; i++) {
        if (values[i] <= max)
            continue;
        fprintf(stderr,
                "%s: parameter %d of option `%s' greater than max=%d\n",
                Program, i + 1, opt, max);
        exit(EXIT_FAILURE);
    }
}

/**********************************************************************/

void checkIntHigher(char *opt, int *values, int count, int min)
{
    int i;

    for (i = 0; i < count; i++) {
        if (values[i] >= min)
            continue;
        fprintf(stderr,
                "%s: parameter %d of option `%s' smaller than min=%d\n",
                Program, i + 1, opt, min);
        exit(EXIT_FAILURE);
    }
}

/**********************************************************************/

void checkLongLower(char *opt, long *values, int count, long max)
{
    int i;

    for (i = 0; i < count; i++) {
        if (values[i] <= max)
            continue;
        fprintf(stderr,
                "%s: parameter %d of option `%s' greater than max=%ld\n",
                Program, i + 1, opt, max);
        exit(EXIT_FAILURE);
    }
}

/**********************************************************************/

void checkLongHigher(char *opt, long *values, int count, long min)
{
    int i;

    for (i = 0; i < count; i++) {
        if (values[i] >= min)
            continue;
        fprintf(stderr,
                "%s: parameter %d of option `%s' smaller than min=%ld\n",
                Program, i + 1, opt, min);
        exit(EXIT_FAILURE);
    }
}

/**********************************************************************/

void checkFloatLower(char *opt, float *values, int count, float max)
{
    int i;

    for (i = 0; i < count; i++) {
        if (values[i] <= max)
            continue;
        fprintf(stderr,
                "%s: parameter %d of option `%s' greater than max=%f\n",
                Program, i + 1, opt, max);
        exit(EXIT_FAILURE);
    }
}

/**********************************************************************/

void checkFloatHigher(char *opt, float *values, int count, float min)
{
    int i;

    for (i = 0; i < count; i++) {
        if (values[i] >= min)
            continue;
        fprintf(stderr,
                "%s: parameter %d of option `%s' smaller than min=%f\n",
                Program, i + 1, opt, min);
        exit(EXIT_FAILURE);
    }
}

/**********************************************************************/

void checkDoubleLower(char *opt, double *values, int count, double max)
{
    int i;

    for (i = 0; i < count; i++) {
        if (values[i] <= max)
            continue;
        fprintf(stderr,
                "%s: parameter %d of option `%s' greater than max=%f\n",
                Program, i + 1, opt, max);
        exit(EXIT_FAILURE);
    }
}

/**********************************************************************/

void checkDoubleHigher(char *opt, double *values, int count, double min)
{
    int i;

    for (i = 0; i < count; i++) {
        if (values[i] >= min)
            continue;
        fprintf(stderr,
                "%s: parameter %d of option `%s' smaller than min=%f\n",
                Program, i + 1, opt, min);
        exit(EXIT_FAILURE);
    }
}

/**********************************************************************/

static char *catArgv(int argc, char **argv)
{
    int i;
    size_t l;
    char *s, *t;

    for (i = 0, l = 0; i < argc; i++)
        l += (1 + strlen(argv[i]));
    s = (char *) malloc(l);
    if (!s) {
        fprintf(stderr, "%s: out of memory\n", Program);
        exit(EXIT_FAILURE);
    }
    strcpy(s, argv[0]);
    t = s;
    for (i = 1; i < argc; i++) {
        t = t + strlen(t);
        *t++ = ' ';
        strcpy(t, argv[i]);
    }
    return s;
}

/**********************************************************************/

void showOptionValues(void)
{
    int i;

    printf("Full command line is:\n`%s'\n", cmd.full_cmd_line);

  /***** -phs: Offset phase for the profile */
    if (!cmd.phsP) {
        printf("-phs not found.\n");
    } else {
        printf("-phs found:\n");
        if (!cmd.phsC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.phs);
        }
    }

  /***** -p: The folding period (s) */
    if (!cmd.pP) {
        printf("-p not found.\n");
    } else {
        printf("-p found:\n");
        if (!cmd.pC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.p);
        }
    }

  /***** -pd: The folding period derivative (s/s) */
    if (!cmd.pdP) {
        printf("-pd not found.\n");
    } else {
        printf("-pd found:\n");
        if (!cmd.pdC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.pd);
        }
    }

  /***** -pdd: The folding period 2nd derivative (s/s^2) */
    if (!cmd.pddP) {
        printf("-pdd not found.\n");
    } else {
        printf("-pdd found:\n");
        if (!cmd.pddC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.pdd);
        }
    }

  /***** -f: The folding frequency (hz) */
    if (!cmd.fP) {
        printf("-f not found.\n");
    } else {
        printf("-f found:\n");
        if (!cmd.fC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.f);
        }
    }

  /***** -fd: The folding frequency derivative (hz/s) */
    if (!cmd.fdP) {
        printf("-fd not found.\n");
    } else {
        printf("-fd found:\n");
        if (!cmd.fdC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.fd);
        }
    }

  /***** -fdd: The folding frequency 2nd derivative (hz/s^2) */
    if (!cmd.fddP) {
        printf("-fdd not found.\n");
    } else {
        printf("-fdd found:\n");
        if (!cmd.fddC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.fdd);
        }
    }

  /***** -n: The number of bins in the profile.  Defaults to the number of sampling bins which correspond to one folded period */
    if (!cmd.proflenP) {
        printf("-n not found.\n");
    } else {
        printf("-n found:\n");
        if (!cmd.proflenC) {
            printf("  no values\n");
        } else {
            printf("  value = `%d'\n", cmd.proflen);
        }
    }

  /***** -psr: Name of pulsar to fold (do not include J or B) */
    if (!cmd.psrnameP) {
        printf("-psr not found.\n");
    } else {
        printf("-psr found:\n");
        if (!cmd.psrnameC) {
            printf("  no values\n");
        } else {
            printf("  value = `%s'\n", cmd.psrname);
        }
    }

  /***** -rzwcand: The candidate number to fold from 'infile'_rzw.cand */
    if (!cmd.rzwcandP) {
        printf("-rzwcand not found.\n");
    } else {
        printf("-rzwcand found:\n");
        if (!cmd.rzwcandC) {
            printf("  no values\n");
        } else {
            printf("  value = `%d'\n", cmd.rzwcand);
        }
    }

  /***** -rzwfile: Name of the rzw search file to use (include the full name of the file) */
    if (!cmd.rzwfileP) {
        printf("-rzwfile not found.\n");
    } else {
        printf("-rzwfile found:\n");
        if (!cmd.rzwfileC) {
            printf("  no values\n");
        } else {
            printf("  value = `%s'\n", cmd.rzwfile);
        }
    }

  /***** -bincand: Fold a binary pulsar but take the input data from this candidate number in 'infile'_bin.cand */
    if (!cmd.bincandP) {
        printf("-bincand not found.\n");
    } else {
        printf("-bincand found:\n");
        if (!cmd.bincandC) {
            printf("  no values\n");
        } else {
            printf("  value = `%d'\n", cmd.bincand);
        }
    }

  /***** -onoff: A list of white-space separated pairs of numbers from 0.0 to 1.0 that designate barycentric times in our data set when we will actually keep the data. (i.e. '-onoff 0.1 0.4 0.7 0.9' means that we will fold the data set during the barycentric times 0.1-0.4 and 0.7-0.9 of the total time length of the data set) */
    if (!cmd.onoffP) {
        printf("-onoff not found.\n");
    } else {
        printf("-onoff found:\n");
        if (!cmd.onoffC) {
            printf("  no values\n");
        } else {
            printf("  value = `%s'\n", cmd.onoff);
        }
    }

  /***** -bin: Fold a binary pulsar.  Must include all of the following parameters */
    if (!cmd.binaryP) {
        printf("-bin not found.\n");
    } else {
        printf("-bin found:\n");
    }

  /***** -pb: The orbital period (s) */
    if (!cmd.pbP) {
        printf("-pb not found.\n");
    } else {
        printf("-pb found:\n");
        if (!cmd.pbC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.pb);
        }
    }

  /***** -x: The projected orbital semi-major axis (lt-sec) */
    if (!cmd.asinicP) {
        printf("-x not found.\n");
    } else {
        printf("-x found:\n");
        if (!cmd.asinicC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.asinic);
        }
    }

  /***** -e: The orbital eccentricity */
    if (!cmd.eP) {
        printf("-e not found.\n");
    } else {
        printf("-e found:\n");
        if (!cmd.eC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.e);
        }
    }

  /***** -To: The time of periastron passage (MJD) */
    if (!cmd.ToP) {
        printf("-To not found.\n");
    } else {
        printf("-To found:\n");
        if (!cmd.ToC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.To);
        }
    }

  /***** -w: Longitude of periastron (deg) */
    if (!cmd.wP) {
        printf("-w not found.\n");
    } else {
        printf("-w found:\n");
        if (!cmd.wC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.w);
        }
    }

  /***** -wdot: Rate of advance of periastron (deg/yr) */
    if (!cmd.wdotP) {
        printf("-wdot not found.\n");
    } else {
        printf("-wdot found:\n");
        if (!cmd.wdotC) {
            printf("  no values\n");
        } else {
            printf("  value = `%.40g'\n", cmd.wdot);
        }
    }

  /***** -xwin: Send graphics output to the screen */
    if (!cmd.xwinP) {
        printf("-xwin not found.\n");
    } else {
        printf("-xwin found:\n");
    }

  /***** -ps: Send graphics output to a Postscript file */
    if (!cmd.psP) {
        printf("-ps not found.\n");
    } else {
        printf("-ps found:\n");
    }

  /***** -both: Send graphics output both the screen and a Postscript file */
    if (!cmd.bothP) {
        printf("-both not found.\n");
    } else {
        printf("-both found:\n");
    }

  /***** -disp: Don't calculate a new profile.  Just display a previously calculated profile in 'infile'.prof.  Must be called with either -ps or -xwin */
    if (!cmd.dispP) {
        printf("-disp not found.\n");
    } else {
        printf("-disp found:\n");
    }

  /***** -mak: Determine folding parameters from 'infile.mak' */
    if (!cmd.makefileP) {
        printf("-mak not found.\n");
    } else {
        printf("-mak found:\n");
    }

  /***** -noerr: Do not plot error bars */
    if (!cmd.noerrP) {
        printf("-noerr not found.\n");
    } else {
        printf("-noerr found:\n");
    }
    if (!cmd.argc) {
        printf("no remaining parameters in argv\n");
    } else {
        printf("argv =");
        for (i = 0; i < cmd.argc; i++) {
            printf(" `%s'", cmd.argv[i]);
        }
        printf("\n");
    }
}

/**********************************************************************/

void usage(void)
{
    fprintf(stderr, "usage: %s%s", Program, "\
 [-phs phs] [-p p] [-pd pd] [-pdd pdd] [-f f] [-fd fd] [-fdd fdd] [-n proflen] [-psr psrname] [-rzwcand rzwcand] [-rzwfile rzwfile] [-bincand bincand] [-onoff onoff] [-bin] [-pb pb] [-x asinic] [-e e] [-To To] [-w w] [-wdot wdot] [-xwin] [-ps] [-both] [-disp] [-mak] [-noerr] [--] infile\n\
    Folds a time series at a given period and period derivative to make a pulse profile.  May be used for binary pulsars as well.\n\
      -phs: Offset phase for the profile\n\
            1 double value between 0 and 1\n\
            default: `0'\n\
        -p: The folding period (s)\n\
            1 double value between 0 and oo\n\
       -pd: The folding period derivative (s/s)\n\
            1 double value\n\
            default: `0'\n\
      -pdd: The folding period 2nd derivative (s/s^2)\n\
            1 double value\n\
            default: `0'\n\
        -f: The folding frequency (hz)\n\
            1 double value between 0 and oo\n\
       -fd: The folding frequency derivative (hz/s)\n\
            1 double value\n\
            default: `0'\n\
      -fdd: The folding frequency 2nd derivative (hz/s^2)\n\
            1 double value\n\
            default: `0'\n\
        -n: The number of bins in the profile.  Defaults to the number of sampling bins which correspond to one folded period\n\
            1 int value\n\
      -psr: Name of pulsar to fold (do not include J or B)\n\
            1 char* value\n\
  -rzwcand: The candidate number to fold from 'infile'_rzw.cand\n\
            1 int value between 1 and oo\n\
  -rzwfile: Name of the rzw search file to use (include the full name of the file)\n\
            1 char* value\n\
  -bincand: Fold a binary pulsar but take the input data from this candidate number in 'infile'_bin.cand\n\
            1 int value between 1 and oo\n\
    -onoff: A list of white-space separated pairs of numbers from 0.0 to 1.0 that designate barycentric times in our data set when we will actually keep the data. (i.e. '-onoff 0.1 0.4 0.7 0.9' means that we will fold the data set during the barycentric times 0.1-0.4 and 0.7-0.9 of the total time length of the data set)\n\
            1 char* value\n\
      -bin: Fold a binary pulsar.  Must include all of the following parameters\n\
       -pb: The orbital period (s)\n\
            1 double value between 0 and oo\n\
        -x: The projected orbital semi-major axis (lt-sec)\n\
            1 double value between 0 and oo\n\
        -e: The orbital eccentricity\n\
            1 double value between 0 and 0.9999999\n\
            default: `0'\n\
       -To: The time of periastron passage (MJD)\n\
            1 double value between 0 and oo\n\
        -w: Longitude of periastron (deg)\n\
            1 double value between 0 and 360\n\
     -wdot: Rate of advance of periastron (deg/yr)\n\
            1 double value\n\
            default: `0'\n\
     -xwin: Send graphics output to the screen\n\
       -ps: Send graphics output to a Postscript file\n\
     -both: Send graphics output both the screen and a Postscript file\n\
     -disp: Don't calculate a new profile.  Just display a previously calculated profile in 'infile'.prof.  Must be called with either -ps or -xwin\n\
      -mak: Determine folding parameters from 'infile.mak'\n\
    -noerr: Do not plot error bars\n\
    infile: Input data file name (without a suffix) of floating point data.  A '.inf' file of the same name must also exist.\n\
            1 value\n\
version: 23Apr04\n\
");
    exit(EXIT_FAILURE);
}

/**********************************************************************/
Cmdline *parseCmdline(int argc, char **argv)
{
    int i;

    Program = argv[0];
    cmd.full_cmd_line = catArgv(argc, argv);
    for (i = 1, cmd.argc = 1; i < argc; i++) {
        if (0 == strcmp("--", argv[i])) {
            while (++i < argc)
                argv[cmd.argc++] = argv[i];
            continue;
        }

        if (0 == strcmp("-phs", argv[i])) {
            int keep = i;
            cmd.phsP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.phs, 1);
            cmd.phsC = i - keep;
            checkDoubleLower("-phs", &cmd.phs, cmd.phsC, 1);
            checkDoubleHigher("-phs", &cmd.phs, cmd.phsC, 0);
            continue;
        }

        if (0 == strcmp("-p", argv[i])) {
            int keep = i;
            cmd.pP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.p, 1);
            cmd.pC = i - keep;
            checkDoubleHigher("-p", &cmd.p, cmd.pC, 0);
            continue;
        }

        if (0 == strcmp("-pd", argv[i])) {
            int keep = i;
            cmd.pdP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.pd, 1);
            cmd.pdC = i - keep;
            continue;
        }

        if (0 == strcmp("-pdd", argv[i])) {
            int keep = i;
            cmd.pddP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.pdd, 1);
            cmd.pddC = i - keep;
            continue;
        }

        if (0 == strcmp("-f", argv[i])) {
            int keep = i;
            cmd.fP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.f, 1);
            cmd.fC = i - keep;
            checkDoubleHigher("-f", &cmd.f, cmd.fC, 0);
            continue;
        }

        if (0 == strcmp("-fd", argv[i])) {
            int keep = i;
            cmd.fdP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.fd, 1);
            cmd.fdC = i - keep;
            continue;
        }

        if (0 == strcmp("-fdd", argv[i])) {
            int keep = i;
            cmd.fddP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.fdd, 1);
            cmd.fddC = i - keep;
            continue;
        }

        if (0 == strcmp("-n", argv[i])) {
            int keep = i;
            cmd.proflenP = 1;
            i = getIntOpt(argc, argv, i, &cmd.proflen, 1);
            cmd.proflenC = i - keep;
            continue;
        }

        if (0 == strcmp("-psr", argv[i])) {
            int keep = i;
            cmd.psrnameP = 1;
            i = getStringOpt(argc, argv, i, &cmd.psrname, 1);
            cmd.psrnameC = i - keep;
            continue;
        }

        if (0 == strcmp("-rzwcand", argv[i])) {
            int keep = i;
            cmd.rzwcandP = 1;
            i = getIntOpt(argc, argv, i, &cmd.rzwcand, 1);
            cmd.rzwcandC = i - keep;
            checkIntHigher("-rzwcand", &cmd.rzwcand, cmd.rzwcandC, 1);
            continue;
        }

        if (0 == strcmp("-rzwfile", argv[i])) {
            int keep = i;
            cmd.rzwfileP = 1;
            i = getStringOpt(argc, argv, i, &cmd.rzwfile, 1);
            cmd.rzwfileC = i - keep;
            continue;
        }

        if (0 == strcmp("-bincand", argv[i])) {
            int keep = i;
            cmd.bincandP = 1;
            i = getIntOpt(argc, argv, i, &cmd.bincand, 1);
            cmd.bincandC = i - keep;
            checkIntHigher("-bincand", &cmd.bincand, cmd.bincandC, 1);
            continue;
        }

        if (0 == strcmp("-onoff", argv[i])) {
            int keep = i;
            cmd.onoffP = 1;
            i = getStringOpt(argc, argv, i, &cmd.onoff, 1);
            cmd.onoffC = i - keep;
            continue;
        }

        if (0 == strcmp("-bin", argv[i])) {
            cmd.binaryP = 1;
            continue;
        }

        if (0 == strcmp("-pb", argv[i])) {
            int keep = i;
            cmd.pbP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.pb, 1);
            cmd.pbC = i - keep;
            checkDoubleHigher("-pb", &cmd.pb, cmd.pbC, 0);
            continue;
        }

        if (0 == strcmp("-x", argv[i])) {
            int keep = i;
            cmd.asinicP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.asinic, 1);
            cmd.asinicC = i - keep;
            checkDoubleHigher("-x", &cmd.asinic, cmd.asinicC, 0);
            continue;
        }

        if (0 == strcmp("-e", argv[i])) {
            int keep = i;
            cmd.eP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.e, 1);
            cmd.eC = i - keep;
            checkDoubleLower("-e", &cmd.e, cmd.eC, 0.9999999);
            checkDoubleHigher("-e", &cmd.e, cmd.eC, 0);
            continue;
        }

        if (0 == strcmp("-To", argv[i])) {
            int keep = i;
            cmd.ToP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.To, 1);
            cmd.ToC = i - keep;
            checkDoubleHigher("-To", &cmd.To, cmd.ToC, 0);
            continue;
        }

        if (0 == strcmp("-w", argv[i])) {
            int keep = i;
            cmd.wP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.w, 1);
            cmd.wC = i - keep;
            checkDoubleLower("-w", &cmd.w, cmd.wC, 360);
            checkDoubleHigher("-w", &cmd.w, cmd.wC, 0);
            continue;
        }

        if (0 == strcmp("-wdot", argv[i])) {
            int keep = i;
            cmd.wdotP = 1;
            i = getDoubleOpt(argc, argv, i, &cmd.wdot, 1);
            cmd.wdotC = i - keep;
            continue;
        }

        if (0 == strcmp("-xwin", argv[i])) {
            cmd.xwinP = 1;
            continue;
        }

        if (0 == strcmp("-ps", argv[i])) {
            cmd.psP = 1;
            continue;
        }

        if (0 == strcmp("-both", argv[i])) {
            cmd.bothP = 1;
            continue;
        }

        if (0 == strcmp("-disp", argv[i])) {
            cmd.dispP = 1;
            continue;
        }

        if (0 == strcmp("-mak", argv[i])) {
            cmd.makefileP = 1;
            continue;
        }

        if (0 == strcmp("-noerr", argv[i])) {
            cmd.noerrP = 1;
            continue;
        }

        if (argv[i][0] == '-') {
            fprintf(stderr, "\n%s: unknown option `%s'\n\n", Program, argv[i]);
            usage();
        }
        argv[cmd.argc++] = argv[i];
    }                           /* for i */


    /*@-mustfree */
    cmd.argv = argv + 1;
    /*@=mustfree */
    cmd.argc -= 1;

    if (1 > cmd.argc) {
        fprintf(stderr, "%s: there should be at least 1 non-option argument(s)\n",
                Program);
        exit(EXIT_FAILURE);
    }
    if (1 < cmd.argc) {
        fprintf(stderr, "%s: there should be at most 1 non-option argument(s)\n",
                Program);
        exit(EXIT_FAILURE);
    }
    /*@-compmempass */
    return &cmd;
}
